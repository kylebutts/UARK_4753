---
title: "R Lab 5 - Working with Dates"
author: "PUT YOUR NAME HERE"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
---

In preparation for the remainder of the course, we will be thinking about working with data that is arranged in time. 
To do so, we are going to practice working with dates in R.

## Years

The simplest time-series data to deal with is annual data. For example, take `uark_enrollment` below.

```{r}
uark_enrollment <- data.frame(
  year = c(2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024),
  full_time = c(19508, 20379, 21047, 21415, 21668, 22144, 22602, 22193, 22070, 23282, 25214, 28426, 29886),
  part_time = c(5029, 4962, 5190, 5339, 5526, 5414, 5176, 5366, 5492, 5786, 5722, 3714, 3724)
)
uark_enrollment$total <-
  uark_enrollment$full_time + uark_enrollment$part_time

# Make sure the data is sorted by year
uark_enrollment <- sort_by(uark_enrollment, uark_enrollment$year)
```

In this setting, year is just another regular *numeric* variable. 
Let's create a plot of enrollment over time. To do so, plot `year` on the x-axis and `total` on the y-axis.

```{r}
plot(
  x = uark_enrollment$year,
  y = uark_enrollment$total
)
lines(
  x = uark_enrollment$year,
  y = uark_enrollment$total
)
```

What do you see?

## Working with dates

However, when we get to dates (day month year), this gets more difficult. 
Here we have box scores from Arkansas football's 2023 season, but note the days are 

```{r}
# Arkansas' 2023 football games
football <- data.frame(
  date = c(
    "11-11-2023", "11-04-2023", "09-23-2023", "09-02-2023", "10-07-2023",
    "09-16-2023", "09-09-2023", "10-21-2023", "11-24-2023", "10-14-2023",
    "11-18-2023", "09-30-2023"
  ),
  month = c(11, 11, 9, 9, 10, 9, 9, 10, 11, 10, 11, 9),
  day = c(11, 4, 23, 2, 7, 16, 9, 21, 24, 14, 18, 30),
  year = rep(2023, 12L),
  school = rep("Arkansas", 12L),
  opponent = c(
    "Auburn", "Florida", "(12) LSU", "Western Carolina", "(16) Ole Miss", "BYU",
    "Kent State", "Mississippi State", "(10) Missouri", "(11) Alabama",
    "Florida International", "Texas A&M"
  ),
  result = c("L", "W", "L", "W", "L", "L", "W", "L", "L", "L", "W", "L"),
  pts = c(10, 39, 31, 56, 20, 31, 28, 3, 14, 21, 44, 22),
  pts_opponent = c(48, 36, 34, 13, 27, 38, 6, 7, 48, 24, 20, 34)
)

# football <- sort_by(
#   football, football$year, football$month, football$day
# )
```

For example, say I wanted to plot the points scored by Arkansas over the season. 
Try that below, maybe with `date` or with `month`/`day`?

```{r}
plot(x = football$day, y = football$pts)
```








... It's not so easy to do this. For example, if I use `day` on the x-axis, these are not in the correct order.

```{r}
plot(football$day, football$pts)
```

If I try `date`, I just get an error since `football$date` is a string.

The best I could think to do is to kind of fake it by doing 

```{r}
# approximately converts to days since January 1st
plot(football$month * 30 + football$day, football$pts)
```


### Dates in R 

R is a good language, so it turns out R has a bunch of functionality to work with dates. 
I think the easiest way to work with dates is to use the `lubridate` package, so let's load that 

```{r}
# You might need to install this. To do so, run this:
# install.packages("lubridate")
library(lubridate)
```

`lubridate` has a bunch of functions to help work with dates. 
First, we have `date()` which creates a Date object in R
```{r}
today <- date("2024-10-23")
class("2024-10-23")
class(today)
```

```{r}
# Kyle nerding out about y2k
as.numeric(today)
today - date("1970-01-01")

# ISO date standard
```

You can add and subtract days from `Date` objects. `1` is a single *day*.
```{r}
tomorrow <- today + 1
last_class <- today - 2
```

```{r}
last_4_classes <- date(c("2024-10-23", "2024-10-21", "2024-10-16", "2024-10-14"))
```


### Back to football dataset

So returning to our previous problem, we can convert our string of dates to actual dates.
But, if we try with `date`, we will get an error:
```{r}
#| eval: FALSE
date(football$date)
```

This is because the date is in an ambiguous format. It does not know if "11-04-2023" is November 4th or April 11th. (aside, year-month-day is the best format for this and other reasons !)

Instead, lurbidate has a set of functions like `mdy`, `dmy`, `ymd`, etc. that will work.
```{r}
football$date <- mdy(football$date)
```

Now we can plot our scores over time. and look, R will print out pretty labels!!
```{r}
plot(football$date, football$pts)
```

```{r}
football <- sort_by(football, football$date)
# equivalent to 
# football <- sort_by(football, football$year, football$month, football$date)
```



### More `lubridate` functions

Okay, say we have a vector of `Date`s. I can use `lubridate`'s `year()`/`month()`/`day()` functions to extract the components.

Try the month function out on `football$date`. 
What happens if you add the argument `label = TRUE` option to `month`?
```{r}
year(football$date)

month(football$date)
month(football$date, label = TRUE)

# day of month = 
day(football$date)
mday(football$date)

# day of year = days since january 1
yday(football$date)

# day of the week
wday(football$date, label = TRUE)

# Q1, Q2, Q3, Q4
quarter(football$date)
quarter(football$date, type = "year.quarter")
```


### Practice question

What is the most common month in the football dataset? 
Hint: use the `month` and `table` function to help.

```{r}

```



### Sorting by date

In this class, we will often need data to be sorted in order of time. 
The easiest way to do this is by using the `sort_by` function. 
The first argument to this function is the data.frame you want to sort and the second the vector you want to sort based on.
```{r}
football <- sort_by(football, football$date)
# equivalent:
# football[order(football$date), ]
```


## Unemployment data

Let's introduce a new dataset on the rate of unemployment in the US. Sorry for 

```{r}
unemployment <- read.csv("data/unemployment.csv")

# Convert `date` string into a `Date`:
library(lubridate)
unemployment$date <- ymd(unemployment$date)
unemployment <- sort_by(unemployment, unemployment$date)
```


Now, let's make a time-series plot of the unemployment rate over time
```{r}
plot(x = unemployment$date, y = unemployment$unrate)
lines(x = unemployment$date, y = unemployment$unrate)
```


### Calculating autocorrelation of unemployment rate

To calculate the autocorrelation between $y_{t}$ and $y_{t-1}$, we need to "shift" y back by one.

This of course means the final period in our data will not have a lag (we do not have the next period). 
To do so, we can grab all but the first value with `x[-1]` and append a NA at the end like this: `c(x[-1], NA)`

Do this to create the variable `unemployment$unrate_lead1`

```{r}
# Number of time-periods
T <- nrow(unemployment)

# Get y_{t-1}
unemployment$unrate_lag1 <- 
  c(NA, unemployment$unrate[1:(T - 1)])

# Get y_{t-2}
unemployment$unrate_lag2 <- 
  c(NA, NA, unemployment$unrate[1:(T - 2)])

unemployment$unrate_lag3 <- 
  c(NA, NA, NA, unemployment$unrate[1:(T - 3)])

# Grab last-years values
unemployment$unrate_lag12 <- 
  c(
    rep(NA, 12), 
    unemployment$unrate[1:(T - 12)]
  )

unemployment$unrate_lag24 <- 
  c(
    rep(NA, 24), 
    unemployment$unrate[1:(T - 24)]
  )
```

```{r}
table(year(unemployment$date))
```


Then, calculate the autocovariance and autocorrelation between `unrate` and `unrate_lag1` using `cov` and `cov`

```{r}
cor(
  x = unemployment$unrate,
  y = unemployment$unrate_lag1, 
  use = "complete.obs"
)

cor(
  x = unemployment$unrate[1:(T - 1)],
  y = unemployment$unrate[2:T]
)
```

### Try yourself

Try to calculate the second-lag autocorrelation $y_{t}$ and $y_{t-2}$.

Hint: this will create two NAs in the dataset:

```{r}
cor(
  x = unemployment$unrate[1:(T - 2)],
  y = unemployment$unrate[3:T]
)
cor(
  x = unemployment$unrate,
  y = unemployment$unrate_lag2,
  use = "complete.obs"
)
```

```{r}
cor(
  x = unemployment$unrate,
  y = unemployment$unrate_lag12,
  use = "complete.obs"
)
cor(
  x = unemployment$unrate,
  y = unemployment$unrate_lag24,
  use = "complete.obs"
)
```


### Quarters

One important variable we might want is the quarter that a date falls within (Q1, Q2, Q3, and Q4). Let's try to make this using the `quarter` function from lubridate.

```{r}
# make new variable in unemployment called `quarter`
unemployment$quarter <- quarter(unemployment$date)

# Keep yourself from accidentally using quarter as a numeric
unemployment$quarter <- 
  paste("Q", unemployment$quarter)
```


What does the argument `type = "year.quarter"` do? What is the difference?

```{r}
# this is quarter (seasonal pattern)
quarter(unemployment$date)

# this is year-by-quarter
quarter(
  unemployment$date, 
  type = "year.quarter"        
)
```


## Basic time-series regression

As a preview of what is to come, let's see which quarter of the year has the lowest unemployment rate:

```{r}
library(fixest)

# Do not do this
unemployment$q1 <- (quarter(unemployment$date) == 1)
unemployment$q2 <- (quarter(unemployment$date) == 2)
unemployment$q3 <- (quarter(unemployment$date) == 3)
unemployment$q4 <- (quarter(unemployment$date) == 4)

# Do this
est <- feols(
  unrate ~ 0 + i(quarter(date)),
  data = unemployment, vcov = "hc1"
)
etable(est)
```

```{r}
model <- feols(
  pts ~ i(month(date), ref = 9),
  data = football
)
etable(model)
```

```{r}
model <- feols(
  unrate ~ year(date),
  data = unemployment
)
etable(model)

unemployment$unrate_linear <- predict(model)
plot(x = unemployment$date, y = unemployment$unrate)
points(x = unemployment$date, y = unemployment$unrate_linear, col = "blue")
```













